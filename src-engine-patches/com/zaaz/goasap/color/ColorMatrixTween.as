/** * Copyright (c) 2008 ZAAZ, Inc. *  * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */package com.zaaz.goasap.color{	import flash.display.DisplayObject;	import flash.filters.ColorMatrixFilter;		import org.goasap.interfaces.IManageable;	import org.goasap.items.LinearGo;	import org.goasap.PlayStates;		import com.gskinner.geom.ColorMatrix;		/**	 * A class for tweening brightness, contrast, saturation and hue, seprately or in combinations. 	 * 	 * This class utilizes Grant Skinner ColorMatrix class for the the heavy lifting.  	 * See com.gskinner.geom.ColorMatrix for details.  Thanks for the bad-ass code Grant.	 * 	 * 	 * 	 * Developer's Note:	 * There is currently an issue when tweening brightness and contrast at the same time.	 * Also, when the target already has a ColorMatrixFilter applied to it, the tween does	 * not always behave as expected. Sometimes it seems to use relative values when not desired.	 * 	 * 	 * @author Graeme Asher, Jud Holliday (flashdev@zaaz.com)	 */	public class ColorMatrixTween extends LinearGo implements IManageable	{		protected var _target:DisplayObject;		protected var _brightnessTo:Number;		protected var _brightnessStart:Number;		protected var _brightnessChange:Number;		protected var _contrastTo:Number;		protected var _contrastStart:Number;		protected var _contrastChange:Number;		protected var _saturationTo:Number;		protected var _saturationStart:Number;		protected var _saturationChange:Number;		protected var _hueTo:Number;		protected var _hueStart:Number;		protected var _hueChange:Number;		protected var _matrixStart:Array;		protected var _matrixTo:Array;		protected var _matrixChange:Array;				/**		 * Constructor		 */		public function ColorMatrixTween(target:DisplayObject = null, brightnessTo:Number = NaN,  contrastTo:Number = NaN,  saturationTo:Number = NaN,  hueTo:Number = NaN, duration:Number = NaN, easing:Function = null, delay:Number = NaN, brightnessStart:Number = NaN, contrastStart:Number = NaN,  saturationStart:Number = NaN,  hueStart:Number = NaN) 		{			super(delay, duration, easing);						if(target != null) 				this.target = target;			if(!isNaN(brightnessTo))				this.brightnessTo = brightnessTo;							if(!isNaN(brightnessStart))				_brightnessStart = brightnessStart;			if(!isNaN(contrastTo)) 				this.contrastTo = contrastTo;							if(!isNaN(contrastStart))				_contrastStart = contrastStart;			if(!isNaN(saturationTo)) 				this.saturationTo = saturationTo;							if(!isNaN(saturationStart))				_saturationStart = saturationStart;			if(!isNaN(hueTo)) 				this.hueTo = hueTo;							if(!isNaN(hueStart))				_hueStart = hueStart;		}				//Getters & Setters		public function get target():DisplayObject 		{			return _target;		}		public function set target(target:DisplayObject):void 		{			if(super._state == PlayStates.STOPPED) 				_target = target;		}		public function get brightnessTo():Number 		{			return _brightnessTo;		}		public function set brightnessTo(value:Number):void 		{			if(super._state == PlayStates.STOPPED) 				_brightnessTo = value;		}		public function get brightnessStart():Number		{			return _brightnessStart;			}		public function set brightnessStart(value:Number):void		{			if(super._state == PlayStates.STOPPED) 				_brightnessStart = value;			}		public function get contrastTo():Number 		{			return _contrastTo;		}		public function set contrastTo(value:Number):void 		{			if(super._state == PlayStates.STOPPED) 				_contrastTo = value;		}		public function get contrastStart():Number		{			return _contrastStart;			}		public function set contrastStart(value:Number):void		{			if(super._state == PlayStates.STOPPED) 				_contrastStart = value;			}		public function get saturationTo():Number 		{			return _saturationTo;		}		public function set saturationTo(value:Number):void 		{			if(super._state == PlayStates.STOPPED) 				_saturationTo = value;		}		public function get saturationStart():Number		{			return _saturationStart;			}		public function set saturationStart(value:Number):void		{			if(super._state == PlayStates.STOPPED) 				_saturationStart = value;			}		public function get hueTo():Number 		{			return _hueTo;		}		public function set hueTo(value:Number):void 		{			if(super._state == PlayStates.STOPPED) 				_hueTo = value;		}		public function get hueStart():Number		{			return _hueStart;			}		public function set hueStart(value:Number):void		{			if(super._state == PlayStates.STOPPED) 				_hueStart = value;			}		//Overiden Methods		override public function start():Boolean 		{			if(target == null || ( isNaN(brightnessTo) && isNaN(contrastTo) && isNaN(saturationTo) && isNaN(hueTo) )) 				return false;							var filterIndex:int = getFilterIndex(ColorMatrixFilter);										var currMatrix:Array;			if (filterIndex != -1)			{//				trace("already has a ColorMatrixFilter applied");				currMatrix = target.filters[filterIndex].matrix;			}			else			{				filterIndex = 0;			}									var cmTo:ColorMatrix = (super.useRelative) ? new ColorMatrix(currMatrix) : new ColorMatrix();						if (!isNaN(_contrastTo))			{				cmTo.adjustContrast(_contrastTo);				}			if (!isNaN(_brightnessTo))			{				cmTo.adjustBrightness(_brightnessTo);				}			if (!isNaN(_saturationTo))			{				cmTo.adjustSaturation(_saturationTo);				}			if (!isNaN(_hueTo))			{				cmTo.adjustHue(_hueTo);				}						_matrixTo = cmTo;										//Set start values if they exist.			var cmStart:ColorMatrix = new ColorMatrix(currMatrix);							if (!isNaN(_contrastStart))			{				cmStart.adjustContrast(_contrastStart);				}			if (!isNaN(_brightnessStart))			{				cmStart.adjustBrightness(_brightnessStart);				}			if (!isNaN(_saturationStart))			{				cmStart.adjustSaturation(_saturationStart);				}			if (!isNaN(_hueStart))			{				cmStart.adjustHue(_hueStart);				}						_matrixStart = cmStart;									//set start matrix			var currFilters:Array = target.filters;			currFilters[filterIndex] = new ColorMatrixFilter(_matrixStart);					target.filters = currFilters;						_matrixChange = new Array();			for (var i:int=0; i<_matrixTo.length; i++)			{				_matrixChange[i] = _matrixTo[i] - _matrixStart[i];			}						return super.start();		}		override protected function onUpdate(type:String):void 		{			var newMatrix:Array = new Array();			for (var i:int=0; i<_matrixTo.length; i++)			{				newMatrix[i] = _matrixStart[i] + (_matrixChange[i] * _position);			}						var cm:ColorMatrix = new ColorMatrix(newMatrix);						var filterIndex:int = getFilterIndex(ColorMatrixFilter);			var currFilters:Array = target.filters;			currFilters[filterIndex] = new ColorMatrixFilter(cm);					target.filters = currFilters;					}				protected function getFilterIndex(filterClass:Class):int 		{			for(var i:uint = 0;i < target.filters.length; i++) 			{				if(target.filters[i] is filterClass) 					return i;			}			return -1;		}		// IManageable implementation		public function getActiveTargets():Array 		{			return [_target];		}		public function getActiveProperties():Array 		{			return ["colorTransform"];		}		public function isHandling(properties:Array):Boolean 		{			if(state == PlayStates.STOPPED)                return false;                			return (properties.indexOf("colorTransform") > -1);		}		public function releaseHandling(...params):void 		{			stop();		}	}}