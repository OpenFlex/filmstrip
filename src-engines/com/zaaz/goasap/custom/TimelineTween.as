/** * Copyright (c) 2008 ZAAZ Inc. *  * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */ package com.zaaz.goasap.custom{	import flash.display.FrameLabel;	import flash.display.MovieClip;	import flash.display.Stage;
	import org.goasap.GoEngine;	import org.goasap.PlayableBase;	import org.goasap.events.GoEvent;	import org.goasap.interfaces.IManageable;	import org.goasap.interfaces.IPlayable;	import org.goasap.interfaces.IUpdatable;	import org.goasap.PlayStates;	
	/**	 * A tweening class for playing a timeline forward or backwards.	 * Auto senses direction of desired destination or accepts forced directional playback.	 * Iterative looping as well as looping forward and backwards.	 * Forced frame rate for accelerated or decelerated playback.	 * 					 * @author Graeme Asher (flashdev@zaaz.com)	 */	//TODO add support for frame number not just frame label as destinations.	//TODO possibly add support for mulitple frames labels as destinations so you could cycle back an forth.	public class TimelineTween extends PlayableBase implements IPlayable,IUpdatable,IManageable	{		protected static const AUTOSENSE:int = 0;		protected static const FORWARD:int = 1;		protected static const REVERSE:int = -1;
		protected var _target:MovieClip;		protected var _frameLabel:FrameLabel;		protected var _direction:int;		protected var _loop:uint;		protected var _frameRate:uint;		protected var _currentStep:uint;
				/**		 * Constructor		 * @param target		A MovieClip		 * @param frameLabel	A String of the frame label on the timeline to use as destination.		 * @param direction		Forces the direction of timeline playback.  Good for use with the loop param.		 * 						0 = AUTOSENSING, the timeline will play forward or backwards based on the location of the current frame vs. the destination frame.		 * 						1 = FORWARD.		 * 						2 = REVERSE.		 * @param cycle			The number of times the timeline should cycle through its playback.  This will force looping forward or backwards as required.		 * @param frameRate		Overrides the frame rate of the target for playback.		 */		public function TimelineTween(target:MovieClip, frameLabel:String, direction:int = 0, loop:uint = 0, frameRate:uint = 0) 		{			super();			_target = target;						if(direction == 0) 				_direction = AUTOSENSE;			else if(direction == 1) 				_direction = FORWARD;			else if(direction == -1) 				_direction = REVERSE;			else 				trace("You have specified an invalid int for forced direction.  Check API.");						var curLabels:Array = _target.currentLabels;
			for(var i:Number = 0;i < curLabels.length; i++)			{				var fl:FrameLabel = curLabels[i] as FrameLabel;				if(fl.name == frameLabel)				{					_frameLabel = fl;					break;				}			}						if(_frameLabel == null)				{				var errorStr:String = "The frame label or frame number you have specified does not exist within the target that you have specified.";				trace(errorStr);				throw new Error(errorStr);			}						if(_direction == AUTOSENSE)				_direction = (_frameLabel.frame > _target.currentFrame) ? FORWARD : REVERSE;						_loop = loop;			_frameRate = (frameRate > 0) ? frameRate : _target.stage.frameRate;			_currentStep = _target.currentFrame;		}
		
		//IPlayable Required Methods		/**		 * Start playing.		 * @return	Boolean		 */		public function start():Boolean		{			if(_frameLabel.frame == _target.currentFrame && _loop < 1)			{				dispatchEvent(new GoEvent(GoEvent.COMPLETE));				return false;			}			else			{				stop();				if(GoEngine.hasItem(this)) 					return false;									dispatchEvent(new GoEvent(GoEvent.START));				_state = PlayStates.PLAYING;				return GoEngine.addItem(this);			}		}
		
		/**		 * Stop playing.		 * @return	Boolean		 */		public function stop():Boolean		{			if(_state == PlayStates.STOPPED)				return false;							if(GoEngine.removeItem(this) == false)				return false;							dispatchEvent(new GoEvent((isDestinationFrame() ? GoEvent.COMPLETE : GoEvent.STOP)));			_state = PlayStates.STOPPED;			return true;		}
		/**		 * Pause play.		 * @return	Boolean		 */		public function pause():Boolean		{			if(_state == PlayStates.PAUSED) 				return true;							if(_state == PlayStates.STOPPED) 				return false;							_state = PlayStates.PAUSED;			return true;		}
		/**		 * Resume paused play.		 * @return	Boolean		 */		public function resume():Boolean		{			if(_state != PlayStates.PAUSED) 				return false;							_state = PlayStates.PLAYING;			return true;		}
		/**		 * @param position	Index indicating point in animation to skipTo.		 */		public function skipTo(position:Number):Boolean		{			//currently not supported			//TODO - determine exactly how this should be implemented with frame label vs frame number.			return false;		}
		
		//IUpdatable Required Methods		/**		 * Defines the pulse on which update is called. 		 * @return	A number of milliseconds for Timer-based updates or GoEngine.ENTER_FRAME (-1)  		 * 			for updates synced to the Flash Player's framerate. 		 */		public function get pulseInterval():int 		{			return (1000 / _frameRate);		}
		/**		 * Perform updates on a pulse.		 * 		 * @param currentTime	A clock time that should be used instead of getTimer		 * 						in performing update calculations. (The value is usually 		 * 						not more than a couple milliseconds different than getTimer		 * 						but using it tightly syncs all items in the timer group		 * 						and can make a perceptible difference.)		 */		public function update(currentTime:Number):void		{			_currentStep += _direction;						if(_currentStep < 1 || _currentStep > _target.totalFrames) 			{				if(_currentStep < 1) 					_currentStep = _target.totalFrames;				else if(_currentStep > _target.totalFrames) 					_currentStep = 1;									_target.gotoAndStop(_currentStep);				dispatchEvent(new GoEvent(GoEvent.UPDATE));				if(isDestinationFrame())					stop();				}			else if(isDestinationFrame())			{				_target.gotoAndStop(_currentStep);				stop();			}			else			{				_target.gotoAndStop(_currentStep);				dispatchEvent(new GoEvent(GoEvent.UPDATE));				}		}
		//Public Methods		/**		 * Reverses the direction of the timeline playback mid tween.		 * @return	Boolean		 */		public function reverseDirection():Boolean		{			if(_state == PlayStates.PLAYING)			{				_direction = (_direction == FORWARD) ? REVERSE : FORWARD;				return true;			}			return false;		}
		//Private Methods		/**		 * Checks to see if the current frame is the destination frame.		 * @return Boolean		 */		private function isDestinationFrame():Boolean		{			if(_loop == 0)				return (_currentStep == _frameLabel.frame) ? true : false;			else if(_loop > 0 && _currentStep == _frameLabel.frame)				_loop--;			return false;		}
		// IManageable implementation		public function getActiveTargets():Array 		{			return [_target];		}
		public function getActiveProperties():Array 		{			return ["currentFrame"];		}
		public function isHandling(properties:Array):Boolean 		{			if(state == PlayStates.STOPPED)                return false;                			return (properties.indexOf("currentFrame") > -1);		}
		public function releaseHandling(...params):void 		{			stop();		}	}}